//
// Testing elliptic curve math
// -----------------------------------------------------------------------------
module("ec");

var ecparams = getSECCurveByName("secp256k1");
var rng = new SecureRandom();

test("Classes", function () {
  expect(3);
  ok(ECPointFp, "ECPointFp");
  ok(ECFieldElementFp, "ECFieldElementFp");
  ok(ECCurveFp, "ECCurveFp");
});

test("Point multiplication", function () {
  expect(5);

  var G = ecparams.getG();
  var n = ecparams.getN();

  ok(G.multiply(n).isInfinity(), "Gn is infinite");

  var k = Bitcoin.ECDSA.getBigRandom(n);
  var P = G.multiply(k);
  ok(!P.isInfinity(), "kG is not infinite");
  ok(P.isOnCurve(), "kG on curve");
  ok(P.multiply(n).isInfinity(), "kGn is infinite");

  ok(P.validate(), "kG validates as a public key");
});


//
// Testing ECDSA
// -----------------------------------------------------------------------------
module("ecdsa");

test("Classes", function () {
  expect(2);
  ok(Bitcoin.ECDSA, "Bitcoin.ECDSA");
  ok(Bitcoin.ECKey, "Bitcoin.ECKey");
});

test("Keys & Key Management", function () {
  expect(5);

  var s1 = new Bitcoin.ECKey();
  var p1 = s1.getPub();
  equal(p1.length, 65, "Public key is correct length");

  var p1_q = ECPointFp.decodeFrom(ecparams.getCurve(), p1);
  ok(p1_q, "Decode point from generated bytestring");
  ok(p1_q.validate(), "Is a valid public point");

  var p2 = Crypto.util.hexToBytes(
    "0486f356006a38b847bedec1bf47013776925d939d5a35a97a4d1263e550c7f1a" +
    "b5aba44ab74d22892097a0e851addf07ba97e33416df5affaceeb35d5607cd23c"
  );
  var p2_q = ECPointFp.decodeFrom(ecparams.getCurve(), p2);
  ok(p2_q, "Decode point from constant");
  ok(p2_q.validate(), "Is a valid public point");
});

test("Signing and Verifying", function () {
  expect(5);

  var s1 = new Bitcoin.ECKey();
  var sig_a = s1.sign(BigInteger.ZERO);
  ok(sig_a, "Sign null");
  ok(s1.verify(BigInteger.ZERO, sig_a));
  
  var message = new BigInteger(1024, rng).toByteArrayUnsigned();
  var hash = Crypto.SHA256(message, {asBytes: true});
  var sig_b = s1.sign(hash);
  ok(sig_b, "Sign random string");
  ok(s1.verify(hash, sig_b));

  var message2 = Crypto.util.hexToBytes(
    "12dce2c169986b3346827ffb2305cf393984627f5f9722a1b1368e933c8d" +
    "d296653fbe5d7ac031c4962ad0eb1c4298c3b91d244e1116b4a76a130c13" +
    "1e7aec7fa70184a71a2e66797052831511b93c6e8d72ae58a1980eaacb66" +
    "8a33f50d7cefb96a5dab897b5efcb99cbafb0d777cb83fc9b2115b69c0fa" +
    "3d82507b932b84e4"
  );
  var hash2 = Crypto.SHA256(message2, {asBytes: true});
  var sig_c = Crypto.util.hexToBytes(
    "3044022038d9b8dd5c9fbf330565c1f51d72a59ba869aeb2c2001be959d3" +
    "79e861ec71960220a73945f32cf90d03127d2c3410d16cee120fa1a4b4c3" +
    "f273ab082801a95506c4"
  );
  var s2 = Crypto.util.hexToBytes(
    "045a1594316e433fb91f35ef4874610d22177c3f1a1060f6c1e70a609d51" +
    "b20be5795cd2a5eae0d6b872ba42db95e9afaeea3fbb89e98099575b6828" +
    "609a978528"
  );
  ok(Bitcoin.ECDSA.verify(hash2, sig_c, s2), "Verify constant signature");
});

//
// Testing Paillier
// -----------------------------------------------------------------------------
module("paillier");

test("Classes", function () {
  expect(3);
  ok(Bitcoin.Paillier, "Bitcoin.Paillier");
  ok(Bitcoin.Paillier.PublicKey, "Bitcoin.Paillier.PublicKey");
  ok(Bitcoin.Paillier.PrivateKey, "Bitcoin.Paillier.PrivateKey");
});

//
// Testing Address
// -----------------------------------------------------------------------------
module("Addresses");

test("Standard Addresses - Prod network", function () {
  expect(7);
  ok(Bitcoin.Address, "Bitcoin.Address");
  Bitcoin.setNetwork('prod');
  var addrString = '1Hinfhwcv3QGv2wYDyenQECR5QXnxBcz1w';
  var address = new Bitcoin.Address(addrString);
  ok(address, "Address from string address");
  equal(address.toString(), addrString, "toString");
  equal(true, address.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(false, address.isP2SHAddress(), 'isPubKeyHash');
  equal(true, Bitcoin.Address.validate(addrString), 'validate');
  equal(false, Bitcoin.Address.validate('xyzzy'), 'validate invalid string');
});

test("MultiSig Addresses - Prod network", function () {
  expect(5);
  Bitcoin.setNetwork('prod');
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey().getPub());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  ok(multiSigAddress, "createMultiSigAddress");
  ok(multiSigAddress.toString(), "toString");
  equal(false, multiSigAddress.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(true, multiSigAddress.isP2SHAddress(), 'isPubKeyHash');

  equal(true, Bitcoin.Address.validate(multiSigAddress.toString()), 'validate');
});

test("Standard Addresses - Test network", function () {
  expect(6);
  Bitcoin.setNetwork('testnet');
  var addrString = 'mgv5oJf5tv5YifH9xTuneRNEbRdG5ryocq';
  var address = new Bitcoin.Address(addrString);
  ok(address, "Address from string address");
  equal(address.toString(), addrString, "toString");
  equal(true, address.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(false, address.isP2SHAddress(), 'isPubKeyHash');
  equal(true, Bitcoin.Address.validate(addrString), 'validate');
  equal(false, Bitcoin.Address.validate('xyzzy'), 'validate invalid string');
});

test("MultiSig Addresses - Test network", function () {
  expect(5);
  Bitcoin.setNetwork('testnet');
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey().getPub());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  ok(multiSigAddress, "createMultiSigAddress");
  ok(multiSigAddress.toString(), "toString");
  equal(false, multiSigAddress.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(true, multiSigAddress.isP2SHAddress(), 'isPubKeyHash');

  equal(true, Bitcoin.Address.validate(multiSigAddress.toString()), 'validate');
});

test("MultiSig Addresses - reject bad args", function() {
  expect(1);
  Bitcoin.setNetwork('prod');
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey());
  }
  throws(function() {
    // Can't create using ECKey - must be an array of pubKeys
    var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  });
});

test("Construction", function() {
  expect(6);
  var key = new Bitcoin.ECKey();
  throws(function() { new Bitcoin.Address() }, "Missing data");
  var address = new Bitcoin.Address(key.getBitcoinAddress().toString());
  ok(address, "from string");
  equal(key.getBitcoinAddress().toString(), address.toString(), "from string");
  equal(Bitcoin.Address.pubKeyHashVersion, address.version, "version");
  address = new Bitcoin.Address(key);
  ok(address, "from eckey");
  equal(key.getBitcoinAddress().toString(), address.toString(), "from eckey");
});

//
// Testing ECKey
// -----------------------------------------------------------------------------
module("ECKey");

test("Prod network", function() {
  expect(3);
  Bitcoin.setNetwork('prod');
  var addrString = '18J3WnE5t3xn6xYeugHwXC4MBbPB9irWem';
  var privKeyString = '5J7MRWpRSPFSDvC4A6pnp58F1nJGri9cQuAtwr6f393958RqKD6';

  var eckey = new Bitcoin.ECKey();
  ok(eckey, "create");

  eckey = new Bitcoin.ECKey(privKeyString);
  ok(eckey, "decode from private key string");
  equal(eckey.getBitcoinAddress().toString(), addrString, "getBitcoinAddress");
});

test("Test network", function() {
  expect(3);
  Bitcoin.setNetwork('testnet');
  var addrString = 'mjcwLf1Kt7m3k941Qb2m5m2JXRwuE5op1F';
  var privKeyString = '93ETBJspobVrHcX5jedm3G7mhpvwyqGk4CjkorjMhUGDVm2bYqw';

  var eckey = new Bitcoin.ECKey();
  ok(eckey, "create");

  eckey = new Bitcoin.ECKey(privKeyString);
  ok(eckey, "decode from private key string");
  equal(eckey.getBitcoinAddress().toString(), addrString, "getBitcoinAddress");
});

//
// Testing Script
// -----------------------------------------------------------------------------
module("Script");

test("Build Scripts", function() {
  expect(4);
  var script = new Bitcoin.Script();
  ok(script, "create");
  equal(undefined, script.writeOp(Bitcoin.Opcode.OP_0), "writeOp");
  equal(undefined, script.writeBytes('hello world'), "writeBytes");
  equal('Strange', script.getOutType(), "getOutputType");
});

test("Pay To PubKey Hash Output Script", function() {
  expect(5);
  var key = new Bitcoin.ECKey();
  var address = new Bitcoin.Address(key);
  var script = Bitcoin.Script.createOutputScript(address);
  ok(script, "createOutputScript");
  equal(script.chunks.length, 5);

  equal('Address', script.getOutType(), "Output Script Type");

  var addresses = [];
  script.extractAddresses(addresses);
  equal(1, addresses.length, "extract addresses count");
  equal(address.toString(), addresses[0].toString(), "extract addresses");
});

test("Pay To Script Hash Output Script", function() {
  expect(5);
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey().getPub());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  var script = Bitcoin.Script.createOutputScript(multiSigAddress);
  ok(script, "createOutputScript");
  equal(script.chunks.length, 3);

  equal('P2SH', script.getOutType(), "Output Script Type");

  var addresses = [];
  script.extractAddresses(addresses);
  equal(1, addresses.length, "extract addresses count");
  equal(multiSigAddress.toString(), addresses[0].toString(), "extract addresses");
});

test("Decode MultiSig Input Script", function() {
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey().getPub());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  ok(multiSigAddress, 'created address');
  var redeemScript = multiSigAddress.redeemScript;
  ok(redeemScript, 'got redeem script');

  var hex = Bitcoin.Util.bytesToHex(redeemScript);
  ok(hex, 'converted to hex');
  var bytes = Bitcoin.Util.hexToBytes(hex);
  ok(bytes, 'converted back to bytes');
  var script = new Bitcoin.Script(bytes);
  ok(script, 'created script');

  var addresses = [];
  var count = script.extractMultiSigPubKeys(addresses);
  equal(count, 3, 'found right number of addresses');
  deepEqual(addresses[0], keys[0], 'key #0 is ok');
  deepEqual(addresses[1], keys[1], 'key #1 is ok');
  deepEqual(addresses[2], keys[2], 'key #2 is ok');
});


//
// Testing Transaction
// -----------------------------------------------------------------------------
module("Transaction");

test("Construction", function() {
  var transaction = new Bitcoin.Transaction();
  ok(transaction, "create");
  ok(transaction.serialize(), "serialize");
});

test("Add Input", function() {
  var inputTransaction = new Bitcoin.Transaction();
  var transaction = new Bitcoin.Transaction();
  transaction.addInput(inputTransaction, 0);
  ok(transaction, "add input");
  equal(1, transaction.ins.length, "input length");
});

test("Parse", function() {
  Bitcoin.setNetwork('prod');
  var txString = '010000000109a6b9c2dfb6e079b999fc70253daec45113435f424c2e20a119c00bac10b3f2000000008a473044022037b4f12c6f74cbaf01b436a87690ba64ec261bd5f46684b3740f516345c0820802206f11e21666af0284909e98f82a036be4923ef6b69b341413b41fd1af9905c508014104eea86b034ea326a28aac964594802fa458455bafe71b7107fa0aad808391265ac0a6e0b9ddb2a4770631792c870c9ce19075c2d41e62f60bce62b9751f19e116ffffffff0150c30000000000001976a9147b76594a27264f6bdd7f0c4a14735aa3421d22fb88ac00000000';
  var txBytes = Crypto.util.hexToBytes(txString);
  var tx = Bitcoin.Transaction.deserialize(txBytes);
  ok(tx, "deserialize");
  equal(1, tx.ins.length, "input length");
  equal(1, tx.outs.length, "output length");
});


//
// Testing Random
// -----------------------------------------------------------------------------
module("Random");

test("Byte Random", function() {
  var random = new SecureRandom();
  var randomArray = new Array(16);

  random.nextBytes(randomArray);
  equal(16, randomArray.length, 'random array fill length');

  var foundNonzero = false;
  for (var index = 0; index < randomArray.length; ++index) {
    var elt = randomArray[index];
    equal(true, (elt >= 0 && elt < 256), 'random elt #' + index + ' is in range');
    if (elt != 0) {
      foundNonzero = true;
    }
  }
  equal(true, foundNonzero, 'not just a bunch of zeroes');
});


//
// Testing ECKey Chaining
// -----------------------------------------------------------------------------
module("ECKey Chains");

test("Basic Chaining", function() {
  var eckey = new Bitcoin.ECKey();
  ok(eckey, "created");
  var priv = eckey.priv;

  var random = new SecureRandom();

  var chainCode = new Array(32);
  random.nextBytes(chainCode);

  var newkey = Bitcoin.ECKey.createECKeyFromChain(priv.toByteArrayUnsigned(), chainCode);
  ok(newkey, "created chain from private key");
  notDeepEqual(newkey.getPub(), eckey.getPub(), 'chained public key is not equal to original public key');

  var hash = new Array(32);
  random.nextBytes(hash);

  // Verify the generated keys are different and can't sign for each other.
  var signature1 = eckey.sign(hash);
  var signature2 = newkey.sign(hash);
  equal(true, eckey.verify(hash, signature1), 'key1 can verify a its own sig');
  notEqual(true, eckey.verify(hash, signature2), 'key1 cannot verify key2\'s sig');
  equal(true, newkey.verify(hash, signature2), 'key2 can verify its own sig');
  notEqual(true, newkey.verify(hash, signature1), 'key2 cannot verify key1\'s sig');

  // Now, can we derive the same public key by chaining just the public key
  var pubkeyChain = Bitcoin.ECKey.createPubKeyFromChain(eckey.getPub(), chainCode);
  ok(pubkeyChain, 'created chain from pubkey');
  deepEqual(pubkeyChain, newkey.getPub(), 'chained public key derived from parent\'s public key matches that dervived from parent\'s private key');
  notDeepEqual(pubkeyChain, eckey.getPub(), 'chained public key derived from parent\'s public key does not match parent');
});

Object.associativeArraySize = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};

test("Parallel Chains", function() {
  var random = new SecureRandom();

  var kNumParallelChains = 6;

  var eckey = new Bitcoin.ECKey();
  var chainedKeys = {};
  for (var index = 0; index < kNumParallelChains; ++index) {
    var chain = new Array(32);
    random.nextBytes(chain);
    var newkey = Bitcoin.ECKey.createECKeyFromChain(eckey.priv.toByteArrayUnsigned(), chain);
    chainedKeys[newkey.getBitcoinAddress().toString()] = { chain: chain, key: newkey };
  }
  equal(Object.associativeArraySize(chainedKeys), kNumParallelChains, "generated unique keys");

  for (var chainedKey in chainedKeys) {
     var elt = chainedKeys[chainedKey];
     var chain = elt.chain;
     var expectedPubKey = elt.key.getPub();
     var chainedPubKey = Bitcoin.ECKey.createPubKeyFromChain(eckey.getPub(), chain);
     deepEqual(chainedPubKey, expectedPubKey, 'derived pubkeys match for case: ' + chainedKey);
  }
});

test("Serial Chains", function() {
  var random = new SecureRandom();

  var kNumSerialChains = 6;

  var eckey = new Bitcoin.ECKey();
  var chainedKeys = [];
  var keyRoot = eckey;
  for (var index = 0; index < kNumSerialChains; ++index) {
    var chain = new Array(32);
    random.nextBytes(chain);
    var newkey = Bitcoin.ECKey.createECKeyFromChain(keyRoot.priv.toByteArrayUnsigned(), chain);
    chainedKeys.push({ chain: chain, key: newkey });
    keyRoot = newkey;
  }
  equal(Object.associativeArraySize(chainedKeys), kNumSerialChains, "generated unique keys");

  var chainHead = eckey.getPub();
  for (var index = 0; index < kNumSerialChains; ++index) {
     var elt = chainedKeys[index];
     var chain = elt.chain;

     var chainedPubKey = Bitcoin.ECKey.createPubKeyFromChain(chainHead, chain);
     var expectedPubKey = elt.key.getPub();

     var bitcoinAddress = Bitcoin.Address.fromPubKey(chainedPubKey);
     deepEqual(chainedPubKey, expectedPubKey, 'derived pubkeys match for case: ' + bitcoinAddress);
     chainHead = chainedPubKey;
  }
});


//
// Testing Util
// -----------------------------------------------------------------------------
module("Util");

test("bytesToBase64 - ok", function() {
  var randomArray = new Array(32);
  new SecureRandom().nextBytes(randomArray);

  var testArrays = [
    [1],
    [1,2,3,4,5,6,7],
    randomArray
  ];
  
  for (var index = 0; index < testArrays.length; ++index) {
    var a = testArrays[index];
    var s = Bitcoin.Util.bytesToBase64(a);
    ok(s, 'encoded test array #' + index);
    var a2 = Bitcoin.Util.base64ToBytes(s);
    ok(a2, 'decoded test array #' + index);
    deepEqual(a, a2, 'decoded array #' + index + ' matched');
  }
});
