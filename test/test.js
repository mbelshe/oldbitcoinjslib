//
// Testing elliptic curve math
// -----------------------------------------------------------------------------
module("ec");

var ecparams = getSECCurveByName("secp256k1");
var rng = new SecureRandom();

test("Classes", function () {
  expect(3);
  ok(ECPointFp, "ECPointFp");
  ok(ECFieldElementFp, "ECFieldElementFp");
  ok(ECCurveFp, "ECCurveFp");
});

test("Point multiplication", function () {
  expect(5);

  var G = ecparams.getG();
  var n = ecparams.getN();

  ok(G.multiply(n).isInfinity(), "Gn is infinite");

  var k = Bitcoin.ECDSA.getBigRandom(n);
  var P = G.multiply(k);
  ok(!P.isInfinity(), "kG is not infinite");
  ok(P.isOnCurve(), "kG on curve");
  ok(P.multiply(n).isInfinity(), "kGn is infinite");

  ok(P.validate(), "kG validates as a public key");
});


//
// Testing ECDSA
// -----------------------------------------------------------------------------
module("ecdsa");

test("Classes", function () {
  expect(2);
  ok(Bitcoin.ECDSA, "Bitcoin.ECDSA");
  ok(Bitcoin.ECKey, "Bitcoin.ECKey");
});

test("Keys & Key Management", function () {
  expect(5);

  var s1 = new Bitcoin.ECKey();
  var p1 = s1.getPub();
  equal(p1.length, 65, "Public key is correct length");

  var p1_q = ECPointFp.decodeFrom(ecparams.getCurve(), p1);
  ok(p1_q, "Decode point from generated bytestring");
  ok(p1_q.validate(), "Is a valid public point");

  var p2 = Crypto.util.hexToBytes(
    "0486f356006a38b847bedec1bf47013776925d939d5a35a97a4d1263e550c7f1a" +
    "b5aba44ab74d22892097a0e851addf07ba97e33416df5affaceeb35d5607cd23c"
  );
  var p2_q = ECPointFp.decodeFrom(ecparams.getCurve(), p2);
  ok(p2_q, "Decode point from constant");
  ok(p2_q.validate(), "Is a valid public point");
});

test("Signing and Verifying", function () {
  expect(5);

  var s1 = new Bitcoin.ECKey();
  var sig_a = s1.sign(BigInteger.ZERO);
  ok(sig_a, "Sign null");
  ok(s1.verify(BigInteger.ZERO, sig_a));
  
  var message = new BigInteger(1024, rng).toByteArrayUnsigned();
  var hash = Crypto.SHA256(message, {asBytes: true});
  var sig_b = s1.sign(hash);
  ok(sig_b, "Sign random string");
  ok(s1.verify(hash, sig_b));

  var message2 = Crypto.util.hexToBytes(
    "12dce2c169986b3346827ffb2305cf393984627f5f9722a1b1368e933c8d" +
    "d296653fbe5d7ac031c4962ad0eb1c4298c3b91d244e1116b4a76a130c13" +
    "1e7aec7fa70184a71a2e66797052831511b93c6e8d72ae58a1980eaacb66" +
    "8a33f50d7cefb96a5dab897b5efcb99cbafb0d777cb83fc9b2115b69c0fa" +
    "3d82507b932b84e4"
  );
  var hash2 = Crypto.SHA256(message2, {asBytes: true});
  var sig_c = Crypto.util.hexToBytes(
    "3044022038d9b8dd5c9fbf330565c1f51d72a59ba869aeb2c2001be959d3" +
    "79e861ec71960220a73945f32cf90d03127d2c3410d16cee120fa1a4b4c3" +
    "f273ab082801a95506c4"
  );
  var s2 = Crypto.util.hexToBytes(
    "045a1594316e433fb91f35ef4874610d22177c3f1a1060f6c1e70a609d51" +
    "b20be5795cd2a5eae0d6b872ba42db95e9afaeea3fbb89e98099575b6828" +
    "609a978528"
  );
  ok(Bitcoin.ECDSA.verify(hash2, sig_c, s2), "Verify constant signature");
});

//
// Testing Paillier
// -----------------------------------------------------------------------------
module("paillier");

test("Classes", function () {
  expect(3);
  ok(Bitcoin.Paillier, "Bitcoin.Paillier");
  ok(Bitcoin.Paillier.PublicKey, "Bitcoin.Paillier.PublicKey");
  ok(Bitcoin.Paillier.PrivateKey, "Bitcoin.Paillier.PrivateKey");
});

//
// Testing Address
// -----------------------------------------------------------------------------
module("Addresses");

test("Standard Addresses - Prod network", function () {
  expect(7);
  ok(Bitcoin.Address, "Bitcoin.Address");
  Bitcoin.setNetwork('prod');
  var addrString = '1Hinfhwcv3QGv2wYDyenQECR5QXnxBcz1w';
  var address = new Bitcoin.Address(addrString);
  ok(address, "Address from string address");
  equal(address.toString(), addrString, "toString");
  equal(true, address.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(false, address.isP2SHAddress(), 'isPubKeyHash');
  equal(true, Bitcoin.Address.validate(addrString), 'validate');
  equal(false, Bitcoin.Address.validate('xyzzy'), 'validate invalid string');
});

test("MultiSig Addresses - Prod network", function () {
  expect(5);
  Bitcoin.setNetwork('prod');
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  ok(multiSigAddress, "createMultiSigAddress");
  ok(multiSigAddress.toString(), "toString");
  equal(false, multiSigAddress.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(true, multiSigAddress.isP2SHAddress(), 'isPubKeyHash');

  equal(true, Bitcoin.Address.validate(multiSigAddress.toString()), 'validate');
});

test("Standard Addresses - Test network", function () {
  expect(6);
  Bitcoin.setNetwork('testnet');
  var addrString = 'mgv5oJf5tv5YifH9xTuneRNEbRdG5ryocq';
  var address = new Bitcoin.Address(addrString);
  ok(address, "Address from string address");
  equal(address.toString(), addrString, "toString");
  equal(true, address.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(false, address.isP2SHAddress(), 'isPubKeyHash');
  equal(true, Bitcoin.Address.validate(addrString), 'validate');
  equal(false, Bitcoin.Address.validate('xyzzy'), 'validate invalid string');
});

test("MultiSig Addresses - Test network", function () {
  expect(5);
  Bitcoin.setNetwork('testnet');
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  ok(multiSigAddress, "createMultiSigAddress");
  ok(multiSigAddress.toString(), "toString");
  equal(false, multiSigAddress.isPubKeyHashAddress(), 'isPubKeyHash');
  equal(true, multiSigAddress.isP2SHAddress(), 'isPubKeyHash');

  equal(true, Bitcoin.Address.validate(multiSigAddress.toString()), 'validate');
});

test("Construction", function() {
  expect(6);
  var key = new Bitcoin.ECKey();
  throws(function() { new Bitcoin.Address() }, "Missing data");
  var address = new Bitcoin.Address(key.getBitcoinAddress().toString());
  ok(address, "from string");
  equal(key.getBitcoinAddress().toString(), address.toString(), "from string");
  equal(Bitcoin.Address.pubKeyHashVersion, address.version, "version");
  address = new Bitcoin.Address(key);
  ok(address, "from eckey");
  equal(key.getBitcoinAddress().toString(), address.toString(), "from eckey");
});

//
// Testing ECKey
// -----------------------------------------------------------------------------
module("ECKey");

test("Prod network", function() {
  expect(3);
  Bitcoin.setNetwork('prod');
  var addrString = '18J3WnE5t3xn6xYeugHwXC4MBbPB9irWem';
  var privKeyString = '5J7MRWpRSPFSDvC4A6pnp58F1nJGri9cQuAtwr6f393958RqKD6';

  var eckey = new Bitcoin.ECKey();
  ok(eckey, "create");

  eckey = new Bitcoin.ECKey(privKeyString);
  ok(eckey, "decode from private key string");
  equal(eckey.getBitcoinAddress().toString(), addrString, "getBitcoinAddress");
});

test("Test network", function() {
  expect(3);
  Bitcoin.setNetwork('testnet');
  var addrString = 'mjcwLf1Kt7m3k941Qb2m5m2JXRwuE5op1F';
  var privKeyString = '93ETBJspobVrHcX5jedm3G7mhpvwyqGk4CjkorjMhUGDVm2bYqw';

  var eckey = new Bitcoin.ECKey();
  ok(eckey, "create");

  eckey = new Bitcoin.ECKey(privKeyString);
  ok(eckey, "decode from private key string");
  equal(eckey.getBitcoinAddress().toString(), addrString, "getBitcoinAddress");
});

//
// Testing Script
// -----------------------------------------------------------------------------
module("Script");

test("Build Scripts", function() {
  expect(4);
  var script = new Bitcoin.Script();
  ok(script, "create");
  equal(undefined, script.writeOp(Bitcoin.Opcode.OP_0), "writeOp");
  equal(undefined, script.writeBytes('hello world'), "writeBytes");
  equal('Strange', script.getOutType(), "getOutputType");
});

test("Pay To PubKey Hash Output Script", function() {
  expect(5);
  var key = new Bitcoin.ECKey();
  var address = new Bitcoin.Address(key);
  var script = Bitcoin.Script.createOutputScript(address);
  ok(script, "createOutputScript");
  equal(script.chunks.length, 5);

  equal('Address', script.getOutType(), "Output Script Type");

  var addresses = [];
  script.extractAddresses(addresses);
  equal(1, addresses.length, "extract addresses count");
  equal(address.toString(), addresses[0].toString(), "extract addresses");
});

test("Pay To Script Hash Output Script", function() {
  expect(5);
  var keys = [];
  for (var index = 0; index < 3; ++index) {
    keys.push(new Bitcoin.ECKey());
  }
  var multiSigAddress = Bitcoin.Address.createMultiSigAddress(keys, 2);
  var script = Bitcoin.Script.createOutputScript(multiSigAddress);
  ok(script, "createOutputScript");
  equal(script.chunks.length, 3);

  equal('P2SH', script.getOutType(), "Output Script Type");

  var addresses = [];
  script.extractAddresses(addresses);
  equal(1, addresses.length, "extract addresses count");
  equal(multiSigAddress.toString(), addresses[0].toString(), "extract addresses");
});


//
// Testing Transaction
// -----------------------------------------------------------------------------
module("Transaction");

test("Construction", function() {
  var transaction = new Bitcoin.Transaction();
  ok(transaction, "create");
  ok(transaction.serialize(), "serialize");
});

test("Add Input", function() {
  var inputTransaction = new Bitcoin.Transaction();
  var transaction = new Bitcoin.Transaction();
  transaction.addInput(inputTransaction, 0);
  ok(transaction, "add input");
  equal(1, transaction.ins.length, "input length");
});

test("Parse", function() {
  Bitcoin.setNetwork('prod');
  var txString = '010000000109a6b9c2dfb6e079b999fc70253daec45113435f424c2e20a119c00bac10b3f2000000008a473044022037b4f12c6f74cbaf01b436a87690ba64ec261bd5f46684b3740f516345c0820802206f11e21666af0284909e98f82a036be4923ef6b69b341413b41fd1af9905c508014104eea86b034ea326a28aac964594802fa458455bafe71b7107fa0aad808391265ac0a6e0b9ddb2a4770631792c870c9ce19075c2d41e62f60bce62b9751f19e116ffffffff0150c30000000000001976a9147b76594a27264f6bdd7f0c4a14735aa3421d22fb88ac00000000';
  var txBytes = Crypto.util.hexToBytes(txString);
  var tx = Bitcoin.Transaction.deserialize(txBytes);
  ok(tx, "deserialize");
  equal(1, tx.ins.length, "input length");
  equal(1, tx.outs.length, "output length");
});



//
// Testing ECKey Chaining
// -----------------------------------------------------------------------------
module("ECKey Chains");

test("Construction", function() {
  var eckey = new Bitcoin.ECKey();
  ok(eckey, "created");
  var priv = eckey.priv;

  var random = new SecureRandom();

  var chainCode = new Array(32);
  random.nextBytes(chainCode);
  equal(32, chainCode.length);
  var foundNonzero = false;
  for (var index = 0; index < chainCode.length; ++index) {
    equal(true, chainCode[index] >= 0);
    equal(true, chainCode[index] < 256);
    if (chainCode[index] != 0) {
      foundNonzero = true;
    }
  }
  expect(true, foundNonzero);  // RNG that outputs all zeroes is kinda weak!

  var newkey = Bitcoin.ECKey.createECKeyFromChain(priv.toByteArrayUnsigned(), chainCode);
  ok(newkey, "created chain key");
  notDeepEqual(newkey.getPub(), eckey.getPub());

  var hash = new Array(32);
  random.nextBytes(hash);

  // Verify the generated keys are different and can't sign for each other.
  var signature1 = eckey.sign(hash);
  var signature2 = newkey.sign(hash);
  equal(true, eckey.verify(hash, signature1));
  notEqual(true, eckey.verify(hash, signature2));
  equal(true, newkey.verify(hash, signature2));
  notEqual(true, newkey.verify(hash, signature1));

  // Now, can we derive the same public key by chaining just the public key
  var pubkeyChain = Bitcoin.ECKey.createPubKeyFromChain(eckey.getPub(), chainCode);
  deepEqual(pubkeyChain, newkey.getPub());
  notDeepEqual(pubkeyChain, eckey.getPub());
});
